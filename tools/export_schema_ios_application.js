const fs = require('fs');
const helpers = require('./helpers');
const path = require('path');

const entityHierarchyPath = path.resolve('../entityHierarchy/thing/Item');
const predicateHierarchyPath = path.resolve('../predicateHierarchy/predicate');
const outputFile = './schema.swift';

function getHeader() {
  return '//\n' +
    '//  WARNING: THIS FILE IS AUTOGENERATED; DO NOT CHANGE.\n' +
    '//  Visit https://gitlab.memri.io/memri/schema to learn more\n' +
    '//\n' +
    '//  schema.swift\n' +
    '//  memri\n' +
    '//\n' +
    '//  Created by Ruben Daniels on 4/1/20.\n' +
    '//  Copyright Â© 2020 memri. All rights reserved.\n' +
    '//\n' +
    '\n' +
    'import Foundation\n' +
    'import Combine\n' +
    'import SwiftUI\n' +
    'import RealmSwift\n' +
    '\n' +
    'public typealias List = RealmSwift.List\n\n';
}

function getDataItemFamily() {
  // Data item family.
  let output = '// The family of all data item classes\n' +
    'enum DataItemFamily: String, ClassFamily, CaseIterable {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `    case type${entity} = "${entity}"\n`;
  }
  output += '\n    static var discriminator: Discriminator = .type\n\n';

  // Background colors.
  output += '    var backgroundColor: Color {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    // output += `        case .type${entity}: return Color(hex: '${entityHierarchy[entity]['backgroundColor']}')\n`; // TODO
    output += `        case .type${entity}: return Color(hex: "#93c47d")\n`;
  }
  output += '        }\n' +
    '    }\n\n';

  // Foreground colors.
  output += '    var foregroundColor: Color {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    // output += `        case .type${entity}: return Color(hex: '${entityHierarchy[entity]['foregroundColor']}')\n`; // TODO
    output += `        case .type${entity}: return Color(hex: "#fff")\n`;
  }
  output += '        }\n' +
    '    }\n\n';

  // Get primary key function.
  output += '    func getPrimaryKey() -> String {\n' +
    '        return self.getType().primaryKey() ?? \"\"\n' +
    '    }\n\n';

  // Get type function.
  output += '    func getType() -> AnyObject.Type {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `        case .type${entity}: return ${entity}.self\n`;
  }
  output += '        }\n' +
    '    }\n' +
    '}\n';
  return output;
}

function getDataItemClasses() {
  let output = '';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `\n/// ${entityHierarchy[entity]['description']}\n`;
    switch (entity) {
      case 'Item':
        output += `public class SchemaItem: Object, Codable, Identifiable, ObservableObject {\n`;
        break;
      case 'Session':
        output += `class SchemaSession : Item {\n`;
        break;
      case 'Sessions':
        output += `class SchemaSessions : Item {\n`;
        break;
      default:
        output += `class ${entity} : Item {\n`;
    }
    output += `    override var genericType:String { "${entity}" }\n\n`;

    // Properties.
    let dynamicVars = "";
    let realmOptionals = "";
    let relations = "";
    let dynamicVarsDecoder = "";
    let realmOptionalsDecoder = "";
    let relationsDecoder = "";

    for (const property of entityHierarchy[entity]['properties']) {
      // Skip properties already defined in 'Item', as in swift the only inheritance is that every
      // Item extends 'Item'.
      if (entityHierarchy['Item']['properties'].includes(property) && entity !== 'Item') { // TODO make global const
        continue;
      }
      if (Object.keys(predicateHierarchy).includes(property)) {
        let type = predicateHierarchy[property]['expectedTypes'];
        if (type === 'string') {
          dynamicVars += `    @objc dynamic var ${property}:String? = nil\n`;
          dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
        } else if (type === 'datetime') {
          dynamicVars += `    @objc dynamic var ${property}:Date? = nil\n`;
          dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
        } else if (type === 'bool') {
          dynamicVars += `    @objc dynamic var ${property}:Bool = false\n`;
          dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
        } else if (type === 'int') {
          realmOptionals += `    let ${property} = RealmOptional<Int>()\n`;
          realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
        } else if (type === 'float') {
          realmOptionals += `    let ${property} = RealmOptional<Double>()\n`;
          realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
        } else if (type === 'any') {
          realmOptionals += `    let ${property} = List<Relationship>()\n`;
          realmOptionalsDecoder += `            decodeRelationships(decoder, "${property}", Item.self, self.${property}, self)\n`;
        } else {
          relations += `    let ${property} = List<${type}>()\n`;
          relationsDecoder += `            decodeIntoList(decoder, "${property}", self.${property})\n`;
        }
      } else {
        if (property.substring(0, 4) === 'one_') {
          let _property = property.substring(4);
          let type = predicateHierarchy[_property]['expectedTypes'];
          dynamicVars += `    @objc dynamic var ${_property}:${type}? = nil\n`;
          dynamicVarsDecoder += `            ${_property} = try decoder.decodeIfPresent("${_property}") ?? ${_property}\n`;
        }
      }
    }
    output += dynamicVars;
    output += realmOptionals;
    output += relations;
    if (dynamicVars || realmOptionals || relations) output += '\n'

    // Decoder
    output += '    required init () {\n' +
      '        super.init()\n' +
      '    }\n\n';

    output += '    public convenience required init(from decoder: Decoder) throws {\n' +
      '        super.init()\n' +
      '        \n' +
      '        jsonErrorHandling(decoder) {\n';
    if (entityHierarchy[entity]['properties']) {
      output += dynamicVarsDecoder;
      output += realmOptionalsDecoder;
      output += relationsDecoder;
    }
    if (dynamicVarsDecoder || realmOptionalsDecoder || relationsDecoder) output += '\n'
    output += '            try self.superDecode(from: decoder)\n' +
      '        }\n' +
      '    }\n' +
      '}\n';
  }

  output += '}\n';
  return output;
}

let entityHierarchy = {};
let predicateHierarchy = {};
(async () => {
  await helpers.getHierarchy(entityHierarchyPath, entityHierarchy, entityHierarchyPath, 'Item');
  await helpers.getHierarchy(predicateHierarchyPath, predicateHierarchy, predicateHierarchyPath, 'predicate');
  // console.log(entityHierarchy);
  // console.log(predicateHierarchy);

  let output = getHeader();
  output += getDataItemFamily();
  output += getDataItemClasses();

  fs.writeFile(outputFile, output, (err) => {
    if (err) throw err;
    console.log('File saved as ' + outputFile);
  });
})();
