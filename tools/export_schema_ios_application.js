const fs = require('fs');
const helpers = require('./helpers');
const path = require('path');

const entityHierarchyPath = path.resolve('../entityHierarchy/thing/Item');
const predicateHierarchyPath = path.resolve('../predicateHierarchy/predicate');
const outputFile = './schema.swift';

function getHeader() {
  return '//\n' +
    '//  WARNING: THIS FILE IS AUTOGENERATED; DO NOT CHANGE.\n' +
    '//  Visit https://gitlab.memri.io/memri/schema to learn more\n' +
    '//\n' +
    '//  schema.swift\n' +
    '//\n' +
    '//  Copyright Â© 2020 memri. All rights reserved.\n' +
    '//\n' +
    '\n' +
    'import Foundation\n' +
    'import Combine\n' +
    'import SwiftUI\n' +
    'import RealmSwift\n' +
    '\n' +
    'public typealias List = RealmSwift.List\n\n';
}

function getItemFamily() {
  // The Item family.
  let output = '// The family of all data item classes\n' +
    'enum ItemFamily: String, ClassFamily, CaseIterable {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item', 'Datasource', 'UserState'].includes(entity)) continue; // TODO global
    output += `    case type${entity} = "${entity}"\n`;
  }
  output += '\n    static var discriminator: Discriminator = .type\n\n';

  // Background colors.
  output += '    var backgroundColor: Color {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item', 'Datasource', 'UserState'].includes(entity)) continue; // TODO global
    // output += `        case .type${entity}: return Color(hex: '${entityHierarchy[entity]['backgroundColor']}')\n`; // TODO
    output += `        case .type${entity}: return Color(hex: "#93c47d")\n`;
  }
  output += '        }\n' +
    '    }\n\n';

  // Foreground colors.
  output += '    var foregroundColor: Color {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item', 'Datasource', 'UserState'].includes(entity)) continue; // TODO global
    // output += `        case .type${entity}: return Color(hex: '${entityHierarchy[entity]['foregroundColor']}')\n`; // TODO
    output += `        case .type${entity}: return Color(hex: "#fff")\n`;
  }
  output += '        }\n' +
    '    }\n\n';

  // Get primary key function.
  output += '    func getPrimaryKey() -> String {\n' +
    '        return self.getType().primaryKey() ?? \"\"\n' +
    '    }\n\n';

  // Get type function.
  output += '    func getType() -> AnyObject.Type {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Item', 'Datasource', 'UserState'].includes(entity)) continue; // TODO global
    output += `        case .type${entity}: return ${entity}.self\n`;
  }
  output += '        }\n' +
    '    }\n' +
    '}\n';
  return output;
}

function getDataItemClasses() {
  let output = '';
  for (const entity of Object.keys(entityHierarchy)) {
    if (['Datasource', 'UserState'].includes(entity)) continue; // Datasource and UserState are defined elsewhere.
    output += `\n/// ${entityHierarchy[entity]['description']}\n`;

    // A set of Items needs to be prepended with 'Schema' for front end functionality
    switch (entity) {
      case 'Item':
        output += `public class SchemaItem: Object, Codable, Identifiable, ObservableObject {\n`;
        break;
      case 'Session':
        output += `class SchemaSession : Item {\n`;
        break;
      case 'Sessions':
        output += `class SchemaSessions : Item {\n`;
        break;
      case 'SyncState':
        output += `class SyncState: Object, Codable {\n`;
        break;
      case 'Edge':
        output += `class Edge : Object, Codable {\n`;
        break;
      case 'Datasource':
      case 'UserState':
        continue;
      default:
        output += `class ${entity} : Item {\n`;
    }
    if (entity === 'Item') {
      output += `    var genericType: String { "unknown" }\n\n`;
    } else {
      output += `    override var genericType:String { "${entity}" }\n\n`;
    }

    // Properties.
    let dynamicVars = "";
    let realmOptionals = "";
    let relations = "";
    let dynamicVarsDecoder = "";
    let realmOptionalsDecoder = "";
    let relationsDecoder = "";

    for (let property of entityHierarchy[entity]['properties']) {
      // Skip properties already defined in 'Item', as in swift the only inheritance is that every Item extends 'Item'.
      if (entityHierarchy['Item']['properties'].includes(property) && entity !== 'Item' || ['genericType', 'functions'].includes(property)) {
        continue;
      }
      if (Object.keys(predicateHierarchy).includes(property)) {
        let type = predicateHierarchy[property]['expectedTypes'];
        if (type === 'string') {
          dynamicVars += `    @objc dynamic var ${property}:String? = nil\n`;
          dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
        } else if (type === 'datetime') {
          dynamicVars += `    @objc dynamic var ${property}:Date? = nil\n`;
          dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
        } else if (type === 'bool') {
          dynamicVars += `    @objc dynamic var ${property}:Bool = false\n`;
          dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
        } else if (type === 'int') {
          realmOptionals += `    let ${property} = RealmOptional<Int>()\n`;
          realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
        } else if (type === 'float') {
          realmOptionals += `    let ${property} = RealmOptional<Double>()\n`;
          realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
        } else if (type === 'any') {
          realmOptionals += `    let ${property} = List<Relationship>()\n`;
          realmOptionalsDecoder += `            decodeRelationships(decoder, "${property}", Item.self, self.${property}, self)\n`;
        } else {
          relations += `    let ${property} = List<${type}>()\n`;
          relationsDecoder += `            decodeIntoList(decoder, "${property}", self.${property})\n`;
        }
      } else if (property.substring(0, 4) === 'one_') {
        property = property.substring(4);
        let type = predicateHierarchy[property]['expectedTypes'];
        dynamicVars += `    @objc dynamic var ${property}:${type}? = nil\n`;
        dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
      } else if (property.substring(0, 7) === 'linked_') {
        property = property.substring(7);
        let type = predicateHierarchy[property]['expectedTypes'];
        let camelCased = entity.substring(0, 1).toLocaleLowerCase() + entity.substring(1);
        realmOptionals += `    let ${property} = LinkingObjects(fromType: ${type}.self, property: "${camelCased}")\n`;
        realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
      } else {
        console.log(`Error while processing: ${entity}`);
      }
    }
    output += dynamicVars;
    output += realmOptionals;
    output += relations;
    if (dynamicVars || realmOptionals || relations) output += '\n';

    // Decoder
    output += '    required init () {\n' +
      '        super.init()\n' +
      '    }\n\n';

    if (entity === 'Item') {
      output += '    public func superDecode(from decoder: Decoder) throws {\n';
    } else {
      output += '    public convenience required init(from decoder: Decoder) throws {\n' +
        '        super.init()\n' +
        '        \n' +
        '        jsonErrorHandling(decoder) {\n';
    }
    if (entityHierarchy[entity]['properties']) {
      output += dynamicVarsDecoder;
      output += realmOptionalsDecoder;
      output += relationsDecoder;
    }
    if (entity !== 'Item') {
      if (dynamicVarsDecoder || realmOptionalsDecoder || relationsDecoder) output += '\n';
      output += '            try self.superDecode(from: decoder)\n' +
        '        }\n';
    } else {
      output += '    }\n\n' +
        '    /// Deserializes Item from json decoder\n' +
        '    /// - Parameter decoder: Decoder object\n' +
        '    /// - Throws: Decoding error\n' +
        '    required public convenience init(from decoder: Decoder) throws {\n' +
        '        self.init()\n' +
        '        try superDecode(from: decoder)\n' +
        '    }\n\n' +
        '    private enum CodingKeys: String, CodingKey {\n' +
        '        case uid, memriID, deleted, starred, dateCreated, dateModified, dateAccessed, changelog,\n' +
        '            labels, syncState\n';
    }
    output += '    }\n' +
      '}\n';
  }

  return output;
}

let entityHierarchy = {};
let predicateHierarchy = {};
(async () => {
  await helpers.getHierarchy(entityHierarchyPath, entityHierarchy, entityHierarchyPath, 'Item');
  await helpers.getHierarchy(predicateHierarchyPath, predicateHierarchy, predicateHierarchyPath, 'predicate');

  let output = getHeader();
  output += getItemFamily();
  output += getDataItemClasses();

  fs.writeFile(outputFile, output, (err) => {
    if (err) throw err;
    console.log('File saved as ' + outputFile);
  });
})();
