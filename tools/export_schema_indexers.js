const fs = require('fs');
const helpers = require('./helpers');
const path = require('path');

const entityHierarchyPath = path.resolve('../TypeHierarchy/Item');
const predicateHierarchyPath = path.resolve('../EdgeAndPropertyHierarchy');
const outputFile = './schema.py';

function getItemClasses() {
  let attributesItem = entityHierarchy['Item']['properties'].concat(Object.keys(entityHierarchy['Item']['relations']));
  let itemArguments = "";
  let itemClasses = [];
  for (const item of Object.keys(entityHierarchy)) {
    if (['SyncableItem', 'Edge', 'Datasource', 'UserState', 'ViewArguments', 'CVUStateDefinition'].includes(item)) continue;

    let classDescription = `\n# ${entityHierarchy[item]['description']}\n`;
    classDescription = helpers.wrapText(`# ${entityHierarchy[item]['description']}`, 100, '\n# ');

    let ancestry = helpers.getAncestry(entityHierarchy[item]['path'].split('/'));
    let properties = [], edges = [];
    for (const _item in ancestry) {
      properties = properties.concat(entityHierarchy[_item]['properties']);
      edges = edges.concat(Object.keys(entityHierarchy[_item]['relations']));
    }

    let arguments = "", edgesAttribute = "";
    let attributes = [], jsonGets = [], fromJsons = [];
    for (const attribute of properties.concat(edges)) {
      if (['genericType', 'functions', 'updatedFields'].includes(attribute)) continue;
      arguments += `${arguments === '' ? '' : ', '}${attribute}`;
      if (item === 'Item') itemArguments += `${itemArguments === '' ? '' : ', '}${attribute}`;

      if (properties.includes(attribute)) {
        jsonGets.push(`${attribute} = json.get("${attribute}", None)`);
      } else {
        fromJsons.push(`if json.get("${attribute}", None) is not None: ${attribute} = Edge.from_json(json.get("${attribute}", None))`)
        edgesAttribute += `${edgesAttribute === '' ? '' : ' + '}${attribute}`;
      }

      if (attributesItem.includes(attribute) && item !== 'Item') continue;
      attributes.push(`self.${attribute} = ${attribute}`);
    }
    let dataItemClass;
    if (item === 'Item') {
      dataItemClass = `

${classDescription}
class Item:
    ${helpers.wrapText(`def __init__(self, ${arguments})`, 100, '\n' + ' '.repeat(17))}:
        ${helpers.insertList(attributes, 8)}
        self.edges = ${edgesAttribute}

    def __getattribute__(self, name, edge):
        res = self._meta[name]
        if isinstance(res, edge):
            return res.traverse()
        else:
            return res

    def get_edge(self, name):
        return self._meta[name]`;
    } else {
      dataItemClass = `

${classDescription}
class ${item}(Item):
    ${helpers.wrapText(`def __init__(self, ${arguments})`, 100, '\n' + ' '.repeat(17))}:
        ${helpers.wrapText(`super().__init__(self, ${itemArguments})`, 100, '\n' + ' '.repeat(25))}
        ${helpers.insertList(attributes, 8)}
        ${helpers.wrapText(`self.edges = ${edgesAttribute}`, 100, ' \\\n' + ' '.repeat(12))}

    @classmethod
    def from_json(cls, json):
        ${helpers.insertList(jsonGets, 8)}
       
        ${helpers.insertList(fromJsons,8)}
        
        ${helpers.wrapText(`cls(${arguments}`, 100, '\n' + ' '.repeat(12))})`;
    }
    itemClasses.push(dataItemClass);
  }
  return itemClasses;
}

let entityHierarchy = {};
let predicateHierarchy = {};
(async () => {
  await helpers.getHierarchy(entityHierarchyPath, entityHierarchy, entityHierarchyPath, 'Item');
  await helpers.getHierarchy(predicateHierarchyPath, predicateHierarchy, predicateHierarchyPath, 'EdgeOrProperty');

  const itemClasses = getItemClasses();
  const output = `#
#  WARNING: THIS FILE IS AUTOGENERATED; DO NOT CHANGE.
#  Visit https://gitlab.memri.io/memri/schema to learn more.
#
#  schema.py
#
#  Copyright Â© 2020 memri. All rights reserved.
#
${helpers.insertList(itemClasses, 0)}`;

  fs.writeFile(outputFile, output, (err) => {
    if (err) throw err;
    console.log('File saved as ' + outputFile);
  });
})();