const fs = require('fs');
const helpers = require('./helpers');
const path = require('path');

const entityHierarchyPath = path.resolve('../TypeHierarchy/Item');
const predicateHierarchyPath = path.resolve('../EdgeAndPropertyHierarchy');
const outputFile = process.env.NODE_INTEGRATOR_SCHEMA_OUT ? process.env.NODE_INTEGRATOR_SCHEMA_OUT : './schema.js';

function getItemClasses() {
  let attributesItem = entityHierarchy['Item']['properties'].concat(Object.keys(entityHierarchy['Item']['relations']));
  let itemArguments = "";
  let itemClasses = [];
  for (const item of Object.keys(entityHierarchy)) {
    if (['SyncableItem', 'Edge', 'Datasource', 'UserState', 'ViewArguments', 'CVUStateDefinition'].includes(item)) continue;

    let classDescription = `\n// ${entityHierarchy[item]['description']}\n`;
    classDescription = helpers.wrapText(`// ${entityHierarchy[item]['description']}`, 100, '\n// ');

    let ancestry = helpers.getAncestry(entityHierarchy[item]['path'].split('/'));
    let properties = [], edges = [];
    for (const _item in ancestry) {
      properties = properties.concat(entityHierarchy[_item]['properties']);
      edges = edges.concat(Object.keys(entityHierarchy[_item]['relations']));
    }

    let arguments = "", clsArguments = "";
    let attributes = [], fromJsonEdges = [], fromJsonProperties = [], fromJsonEdgeLoop = [];
    for (const attribute of properties.concat(edges)) {
      if (['genericType', 'functions', 'updatedFields', 'allEdges'].includes(attribute)) continue;
      arguments += `${arguments === '' ? '' : ', '}${attribute} = null`;
      clsArguments += `${clsArguments === '' ? '' : ', '}${attribute}`;
      if (item === 'Item') itemArguments += `${itemArguments === '' ? '' : ', '}${attribute}`;
      if (item === 'Item' && attribute === 'uid') continue;

      if (properties.includes(attribute)) {
        fromJsonProperties.push(`let ${attribute} = obj["${attribute}"]`);
      } else {
        fromJsonEdges.push(`let ${attribute} = [];`);
        let ifOrElif = fromJsonEdgeLoop.length === 0 ? 'if' : '} else if';
        fromJsonEdgeLoop.push(`${ifOrElif} (edge._type === "${attribute}" || edge._type === "~${attribute}") { 
          ${attribute}.append(edge);`);
      }
      if (attributesItem.includes(attribute) && item !== 'Item') continue;
      if (edges.includes(attribute)) {
        attributes.push(`this.${attribute} = ${attribute} ? ${attribute} : [];`);
      } else {
        attributes.push(`this.${attribute} = ${attribute};`);
      }
    }
    let dataItemClass;
    if (item === 'Item') {
      dataItemClass = `
${classDescription}
class Item {
  ${helpers.wrapText(`constructor(${arguments})`, 80, '\n' + ' '.repeat(14))} {
    ${helpers.insertList(attributes, 4)}
  }
}`;
    } else {
      dataItemClass = `
${classDescription}
class ${item} extends Item {
  ${helpers.wrapText(`constructor(${arguments})`, 80, '\n' + ' '.repeat(14))} {
    
    ${helpers.wrapText(`super(${itemArguments})`, 80, '\n' + ' '.repeat(6))}
    
    ${helpers.insertList(attributes, 4)}
  }
  
  fromJson(cls, _json) {
    let obj = JSON.parse(_json);
    let allEdges = obj["allEdges"];
    ${helpers.insertList(fromJsonProperties, 4)}
   
    ${helpers.insertList(fromJsonEdges, 4)}
    
    if (allEdges) {
      for (const edgeJson of allEdges) {
        edge = Edge.fromJson(edgeJson);
        ${helpers.insertList(fromJsonEdgeLoop, 8)}
        }
      }
    }
    
    ${helpers.wrapText(`let res = new ${item}(${clsArguments}`, 100, '\n' + ' '.repeat(6))})
    
    for (const e in res.getAllEdges()) {
      res[e]['source'] = res;
    }
    
    return res
  }
}`;
    }
    itemClasses.push(dataItemClass);
  }
  return itemClasses;
}

let entityHierarchy = {};
let predicateHierarchy = {};
(async () => {
  await helpers.getHierarchy(entityHierarchyPath, entityHierarchy, entityHierarchyPath, 'Item');
  await helpers.getHierarchy(predicateHierarchyPath, predicateHierarchy, predicateHierarchyPath, 'EdgeOrProperty');

  const itemClasses = getItemClasses();
  const output = `//
//  WARNING: THIS FILE IS AUTOGENERATED; DO NOT CHANGE.
//  Visit https://gitlab.memri.io/memri/schema to learn more.
//
//  schema.js
//
//  Copyright Â© 2020 memri. All rights reserved.
//
${helpers.insertList(itemClasses, 0)}`;

  fs.writeFile(outputFile, output, (err) => {
    if (err) throw err;
    console.log('File saved as ' + outputFile);
  });
})();