const fs = require('fs');
const helpers = require('./helpers');
const path = require('path');

const entityHierarchyPath = path.resolve('../entityHierarchy/thing/Entity');
const predicateHierarchyPath = path.resolve('../predicateHierarchy');
const outputFile = './schema.swift';

function getHeader() {
  return '//\n' +
    '//  WARNING: THIS FILE IS AUTOGENERATED; DO NOT CHANGE.\n' +
    '//  Visit https://gitlab.memri.io/memri/schema to learn more\n' +
    '//\n' +
    '//  schema.swift\n' +
    '//  memri\n' +
    '//\n' +
    '//  Created by Ruben Daniels on 4/1/20.\n' +
    '//  Copyright Â© 2020 memri. All rights reserved.\n' +
    '//\n' +
    '\n' +
    'import Foundation\n' +
    'import Combine\n' +
    'import SwiftUI\n' +
    'import RealmSwift\n' +
    '\n' +
    'public typeAlias List = RealmSwift.List\n\n';
}

function getDataItemFamily() {
  // Data item family.
  let output = '// The family of all data item classes\n' +
    'enum DataItemFamily: String, ClassFamily, CaseIterable {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `    case type${entity} = '${entity}'\n`;
  }
  output += '\n    static var discriminator: Discriminator = .type\n\n';

  // Background colors.
  output += '    var backgroundColor: Color {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `        case .type${entity}: return Color(hex: '${entityHierarchy[entity]['backgroundColor']}')\n`;
  }
  output += '        }\n' +
    '    }\n\n';

  // Foreground colors.
  output += '    var foregroundColor: Color {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `        case .type${entity}: return Color(hex: '${entityHierarchy[entity]['backgroundColor']}')\n`;
  }
  output += '        }\n' +
    '    }\n\n';

  // Get primary key function.
  output += '    func getPrimaryKey() -> String {\n' +
    '        return self.getType().primaryKey() ?? \'\'\n' +
    '    }\n\n';

  // Get type function.
  output += '    func getType() -> AnyObject.Type {\n' +
    '        switch self {\n';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `        case .type${entity}: return ${entity}.self\n`;
  }
  output += '        }\n' +
    '    }\n' +
    '}';

  return output;
}

function getDataItemClasses() {
  let output = '';
  for (const entity of Object.keys(entityHierarchy)) {
    output += `\n\n/// ${entityHierarchy[entity]['description']}\n`;
    output += `class ${entity}:DataItem {\n`;

    // Properties.
    let dynamicVars = "";
    let realmOptionals = "";
    let relations = "";
    let dynamicVarsDecoder = "";
    let realmOptionalsDecoder = "";
    let relationsDecoder = "";
    for (const property of entityHierarchy[entity]['properties']) {
      if (Object.keys(predicateHierarchy).includes(property)) {
        let types = predicateHierarchy[property]['expectedTypes'].split('\n');
        if (types.length === 1) {
          let type = types[0];
          if (type === 'string') {
            dynamicVars += `    @objc dynamic var ${property}:String? = nil\n`;
            dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
          } else if (type === 'datetime') {
            dynamicVars += `    @objc dynamic var ${property}:Date? = nil\n`;
            dynamicVarsDecoder += `            ${property} = try decoder.decodeIfPresent("${property}") ?? ${property}\n`;
          } else if (type === 'int') {
            realmOptionals += `    let ${property} = RealmOptional<Int>()\n`;
            realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
          } else if (type === 'float') {
            realmOptionals += `    let ${property} = RealmOptional<Double>()\n`;
            realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
          } else if (type === 'boolean') {
            realmOptionals += `    let ${property} = RealmOptional<Bool>()\n`;
            realmOptionalsDecoder += `            ${property}.value = try decoder.decodeIfPresent("${property}") ?? ${property}.value\n`;
          } else {
            relations += `    let ${property} = List<${type}>()\n`;
            relationsDecoder += `            decodeIntoList(decoder, "${property}", self.${property})\n`;
          }
        } else {
          relations += `    let ${property} = List<HeterogeneousEdge>()\n`;
          relationsDecoder += `            decodeIntoList(decoder, "${property}", self.${property})\n`;
        }
      }
    }
    if (dynamicVars !== "") output += dynamicVars + '\n';
    if (realmOptionals !== "") output += realmOptionals + '\n';
    if (relations !== "") output += relations + '\n';

    // Decoder
    output += `    override var genericType:String { "${entity}" }\n\n` +
      '    required init () {\n' +
      '        super.init()\n' +
      '    }\n\n';

    output += '    public required init(from decoder: Decoder) throws {\n' +
      '        super.init()\n' +
      '        \n' +
      '        jsonErrorHandling(decoder) {\n';
    if (entityHierarchy[entity]['properties']) {
      if (dynamicVarsDecoder !== "") output += dynamicVarsDecoder + '\n';
      if (realmOptionalsDecoder !== "") output += realmOptionalsDecoder + '\n';
      if (relationsDecoder !== "") output += relationsDecoder + '\n';
    }
    output += '            try self.superDecode(from: decoder)\n' +
      '        }\n' +
      '    }\n';
  }
  output += '}\n';
  return output;
}

let entityHierarchy = {};
let predicateHierarchy = {};
(async () => {
  await helpers.getHierarchy(entityHierarchyPath, entityHierarchy, entityHierarchyPath);
  await helpers.getHierarchy(predicateHierarchyPath, predicateHierarchy, predicateHierarchyPath);
  console.log(entityHierarchy);
  console.log(predicateHierarchy);

  let output = getHeader();
  output += getDataItemFamily();
  output += getDataItemClasses();

  console.log(predicateHierarchy['deathPlace']['expectedTypes'].split('\n'));

  fs.writeFile(outputFile, output, (err) => {
    if (err) throw err;
    console.log('File saved as ' + outputFile);
  });
})();
